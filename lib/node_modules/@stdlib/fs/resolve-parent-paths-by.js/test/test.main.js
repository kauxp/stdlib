/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var path = require('path');
var tape = require('tape');
var resolveParentPathsBy = require('./../lib/main.js').default; // Adjust path if needed
var IS_BROWSER = require('@stdlib/assert/is-browser');
var contains = require('@stdlib/assert/contains');
var cwd = require('@stdlib/process/cwd');

// VARIABLES //

var opts = {
    'skip': IS_BROWSER // Skip tests in the browser environment
};

// TESTS //

tape('main export is a function', function test(t) {
    t.ok(true, __filename);
    t.strictEqual(typeof resolveParentPathsBy, 'function', 'main export is a function');
    t.end();
});

tape('the function throws an error if provided an invalid `paths` argument', function test(t) {
    var values = [
        5,
        NaN,
        null,
        undefined,
        true,
        {},
        function noop() { },
        'beep',
        [1, 2]
    ];

    values.forEach(function (value) {
        t.throws(badValue(value), TypeError, 'throws a type error when provided ' + value);
    });

    t.end();

    function badValue(value) {
        return function badValue() {
            resolveParentPathsBy(value, {}, noop);
        };
    }
});

tape('the function throws an error if provided an invalid `options` argument', function test(t) {
    var values = [
        5,
        NaN,
        null,
        undefined,
        true,
        [],
        function noop() { },
        'beep'
    ];

    values.forEach(function (value) {
        t.throws(badValue(value), TypeError, 'throws a type error when provided ' + value);
    });

    t.end();

    function badValue(value) {
        return function badValue() {
            resolveParentPathsBy(['foo'], value, noop);
        };
    }
});

tape('the function throws an error if provided an invalid callback', function test(t) {
    var values = [
        '5',
        5,
        NaN,
        null,
        undefined,
        true,
        [],
        {}
    ];

    values.forEach(function (value) {
        t.throws(badValue(value), TypeError, 'throws a type error when provided ' + value);
    });

    t.end();

    function badValue(value) {
        return function badValue() {
            resolveParentPathsBy(['foo'], { mode: 'all' }, value);
        };
    }
});

tape('the function returns an empty array if no paths are resolved', function test(t) {
    var expected = [];
    resolveParentPathsBy(['nonexistent'], { mode: 'all' }, function onPaths(error, paths) {
        t.error(error);
        t.deepEqual(paths, expected, 'returns expected paths');
        t.end();
    });
});

tape('the function resolves paths using `first` mode', function test(t) {
    var expected = [path.resolve(cwd(), 'package.json')];
    resolveParentPathsBy(['package.json'], { mode: 'first' }, function onPaths(error, paths) {
        t.error(error);
        t.deepEqual(paths, expected, 'returns expected paths');
        t.end();
    });
});

tape('the function resolves paths using `some` mode', function test(t) {
    var expected = [path.resolve(cwd(), 'package.json')];
    resolveParentPathsBy(['package.json', 'nonexistent'], { mode: 'some' }, function onPaths(error, paths) {
        t.error(error);
        t.deepEqual(paths, expected, 'returns expected paths');
        t.end();
    });
});

tape('the function resolves paths using `all` mode', function test(t) {
    var expected = [path.resolve(cwd(), 'package.json'), null];
    resolveParentPathsBy(['package.json', 'nonexistent'], { mode: 'all' }, function onPaths(error, paths) {
        t.error(error);
        t.deepEqual(paths, expected, 'returns expected paths');
        t.end();
    });
});

tape('the function resolves paths using `each` mode', function test(t) {
    var expected = [path.resolve(cwd(), 'package.json'), null];
    resolveParentPathsBy(['package.json', 'nonexistent'], { mode: 'each' }, function onPaths(error, paths) {
        t.error(error);
        t.deepEqual(paths, expected, 'returns expected paths');
        t.end();
    });
});
